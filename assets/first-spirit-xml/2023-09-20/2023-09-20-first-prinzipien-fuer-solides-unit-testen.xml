<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<documents>
    <document uid="154bc12dba6cba16a7eed27d6d9c8af5">
        <field name="title"><![CDATA[F.I.R.S.T.-Prinzipien fÃ¼r solides Unit-Testen]]></field>
        <field name="subline"><![CDATA[]]></field>
        <field name="teaser"><![CDATA[<p>F.I.R.S.T. ist ein Akronym, welches verschiedene Prinzipien beim Schreiben von Unit-Tests umfasst.
Die F.I.R.S.T.-Prinzipien wurden von Robert C. Martin in Clean Code kurz vorgestellt und in diesem Blog mÃ¶chte ich weiter in die Tiefe dieser Prinzipien eingehen.
Gerade beim Einstieg in die Programmierung kÃ¶nnen diese Prinzipien als Leitfaden dienen.
Diese Prinzipien haben das Ziel, dass Unit-Tests verstÃ¤ndlich, wartbar und aussagekrÃ¤ftig sind.</p>

]]></field>
        <field name="language_multi_keyword"><![CDATA[de]]></field>
        <field name="content_type_multi_keyword"><![CDATA[blog]]></field>
        <field name="mime_type_multi_keyword"><![CDATA[text/html]]></field>
        <field name="category_multi_keyword"><![CDATA[Softwareentwicklung]]></field>
        <field name="tag_multi_keyword"><![CDATA[Testing]]></field>
        <field name="tag_multi_keyword"><![CDATA[CleanCode]]></field>
        <field name="date_date"><![CDATA[2023-09-20T08:00:00+02:00]]></field>
        <field name="date_l"><![CDATA[1695189600000]]></field>
        <field name="change_date"><![CDATA[1695168000000]]></field>

        <!--Author Information-->
        
        <field name="author_id"><![CDATA[dkstern]]></field><!--Postcontent-->
        <field name="headlines"><![CDATA[F.I.R.S.T.-Prinzipien fÃ¼r solides Unit-Testen]]></field>
        <field name="display_content"><![CDATA[<div class="i2-intro p-t-1">
            <p>F.I.R.S.T. ist ein Akronym, welches verschiedene Prinzipien beim Schreiben von Unit-Tests umfasst.
Die F.I.R.S.T.-Prinzipien wurden von Robert C. Martin in Clean Code kurz vorgestellt und in diesem Blog mÃ¶chte ich weiter in die Tiefe dieser Prinzipien eingehen.
Gerade beim Einstieg in die Programmierung kÃ¶nnen diese Prinzipien als Leitfaden dienen.
Diese Prinzipien haben das Ziel, dass Unit-Tests verstÃ¤ndlich, wartbar und aussagekrÃ¤ftig sind.</p>

</div>]]></field>
        <field name="content"><![CDATA[<div class="adesso-text-formate">
<div class="row p-t-2">
<div class="adesso-container">
<div class="col-xl-8 adesso-center p-b-1 p-l-0 p-r-0">
    <p>F.I.R.S.T. ist ein Akronym, welches verschiedene Prinzipien beim Schreiben von Unit-Tests umfasst.
Die F.I.R.S.T.-Prinzipien wurden von Robert C. Martin in Clean Code kurz vorgestellt und in diesem Blog mÃ¶chte ich weiter in die Tiefe dieser Prinzipien eingehen.
Gerade beim Einstieg in die Programmierung kÃ¶nnen diese Prinzipien als Leitfaden dienen.
Diese Prinzipien haben das Ziel, dass Unit-Tests verstÃ¤ndlich, wartbar und aussagekrÃ¤ftig sind.</p>

<p>Dieser Blog richtet sich an alle frischen und erfahrenen Entwickelnden, welche sich ein wenig mit dem Schreiben von Unit-Tests auseinandersetzen mÃ¶chten.</p>

<h4 id="tldr-ï¸âƒ£">TL;DR #ï¸âƒ£</h4>

<ul>
  <li><strong>F</strong>ast: Unit-Tests sind schnell und dauern nur wenige Millisekunden.</li>
  <li><strong>I</strong>ndependent/<strong>I</strong>solated: Unit-Tests sind unabhÃ¤ngig voneinander und kÃ¶nnen in beliebiger Reihenfolge ausgefÃ¼hrt werden.</li>
  <li><strong>R</strong>epeatable: Unit-Tests werden hÃ¤ufig und auf verschiedenen Umgebungen ausgefÃ¼hrt, dabei liefern diese zuverlÃ¤ssig die gleichen Ergebnisse.</li>
  <li><strong>S</strong>elf Validating: Ergebnisse werden programmatisch ausgewertet und liefern ein binÃ¤res Ergebnis (success/fail).</li>
  <li><strong>T</strong>imely/<strong>T</strong>horough: Unit-Tests werden â€œrechtzeitigâ€ geschrieben, indem diese schon vor dem produktiven Code erstellt werden. AuÃŸerdem wird â€œgrÃ¼ndlichâ€ getestet, indem (neben den ErfolgsfÃ¤llen) auch FehlerfÃ¤lle, Grenzwerte und Ã„quivalenzklassen getestet werden.</li>
</ul>

<h4 id="f---fast-">F - Fast ğŸ‡</h4>

<p>Unit-Tests sind schnell!
MÃ¶chte man nach Anpassungen im Code die Unit-Tests nicht ausfÃ¼hren, weil diese einem persÃ¶nlich zu lange dauern, dann ist dies ein Alarmsignal dafÃ¼r, dass die Tests keine Unit-Tests sind.
Denn ein Unit-Test dauert bei der AusfÃ¼hrung nur wenige Millisekunden und dies sollte keinen signifikanten Einfluss auf die persÃ¶nliche Wahrnehmung haben.
Alleine das Lesen dieses Satzes dauert lÃ¤nger, als die Zeit die mehrere hundert Unit-Tests fÃ¼r die AusfÃ¼hrung benÃ¶tigen.
Dauert ein Unit-Test lÃ¤nger als eine Sekunde, sollte man diesen nochmal genauer betrachten, denn meist verbirgt sich dahinter schon ein Integrationstest.
Bei einem Integrations-Test wird weiterer Code auÃŸerhalb unserer zu testenden Methode oder Funktion ausgefÃ¼hrt.
Dies kann sehr schnell passieren, indem bspw. AbhÃ¤ngigkeiten nicht â€œgemocktâ€ wurden.
Mocks sind Stellvertreter-Objekte/-Funktionen, welche nur in Unit-Tests existieren und so tun, als wÃ¤ren diese ein konkretes Objekt von einer Klasse oder einer Funktion.
Im schlimmsten Fall werden ohne Mocks Live-Services aufgerufen und ehe man sich versieht, hat man erfolgreich seinen ersten kleinen DOS-Angriff durchgefÃ¼hrt oder Testdaten in eine Produktivdatenbank geschrieben.
Es sollte somit klar sein, was fÃ¼r Auswirkungen Tests haben kÃ¶nnen, wenn diese nicht nur den zu testenden Code ausfÃ¼hren.</p>

<h4 id="i---isolated--independent-">I - Isolated / Independent âœŠ</h4>

<p>Unit-Tests sind unabhÃ¤ngig voneinander!
Das Ziel: Unit-Tests kÃ¶nnen in beliebiger Reihenfolge ausgefÃ¼hrt werden und es spielt keine Rolle, welcher Unit-Test davor ausgefÃ¼hrt wurde.
Dementsprechend sollten keine Variablen und Objekte zwischen Unit-Tests geteilt werden, auch nicht das Testobjekt selbst.
Generell, sollten alle AbhÃ¤ngigkeiten bei unserer zu testenden Methode oder Funktion betrachtet und isoliert werden, indem diese bspw. durch Mocks ersetzt werden.
Dadurch werden unerwÃ¼nschte Seiteneffekte vermieden und Unit-Tests werden nicht nur aussagekrÃ¤ftiger, sondern auch besser wartbar.</p>

<h5 id="die-drei-as-oder-auch-given-when-then">Die drei Aâ€™s (oder auch <code>given</code>, <code>when</code>, <code>then</code>)</h5>

<p>Zur besseren Struktur und Auffindbarkeit von AbhÃ¤ngigkeiten, kann die Verwendung von <code>arrange</code>, <code>act</code>, <code>assert</code> oder alternativ <code>given</code>, <code>when</code>, <code>then</code> unterstÃ¼tzen.
Dabei wird ein Unit-Test in drei Bereiche aufgeteilt, indem diese drei SchlagwÃ¶rter als Kommentare in Unit-Test geschrieben werden.</p>

<p>Folgendes sollte in diesen drei Bereichen zu finden sein:</p>

<h6 id="arrange-oder-given"><code>arrange</code> (oder <code>given</code>)</h6>

<p>Hier findet die Testvorbereitung statt, wo Variablen definiert und alle weiteren Konfigurationen gesetzt werden.
Dies ist quasi unsere Einleitung fÃ¼r unseren Unit-Test und sie hilft uns, die Situation besser zu verstehen, die unser Unit-Test abdecken soll.
Wenn alle Unit-Tests dieselbe Testvorbereitung haben, kÃ¶nnen und sollten diese ausgelagert werden.
Dazu bieten in der Regel alle gÃ¤ngigen Test-Frameworks, bspw. JUnit oder Jest, Setup-MÃ¶glichkeiten an, worin unsere Testvorbereitungen ausgelagert werden kÃ¶nnen.
Bei Jest gibt es die Funktionen <code>beforeEach</code> und <code>beforeAll</code>.
Bei JUnit die Annotationen <code>@BeforeEach</code> und <code>@BeforeAll</code>.</p>

<h6 id="act-oder-when"><code>act</code> (oder <code>when</code>)</h6>

<p>Hier befindet sich die eigentliche TestausfÃ¼hrung.
Mit anderen Worten, die zu testende Methode oder Funktion wird hier aufgerufen.</p>

<h6 id="assert-oder-then"><code>assert</code> (oder <code>then</code>)</h6>

<p>In diesem Bereich wird das Ergebnis unseres Tests programmatisch ausgewertet, indem das Ergebnis mit unserer Erwartung verglichen wird.
GrundsÃ¤tzlich sollten Unit-Tests immer nur ein Ergebnis erwarten und auswerten.
Mit anderen Worten, ein Unit-Test enthÃ¤lt in der Regel nur einen <code>assert()</code>- oder <code>expect()</code>-Aufruf.</p>

<p>Zur besseren VerstÃ¤ndlichkeit ein kleines Beispiel:</p>

<p>Wir stellen uns vor, wir haben einen Online-Shop fÃ¼r Katzenbedarf und mÃ¶chten allen Premiumkunden 15 % Rabatt gewÃ¤hren.
Wir haben eine REST-Schnittstelle, welche angesprochen werden kann, um einem User den Rabatt zu gewÃ¤hren (bspw. <code>GET /v1/discount</code>).
Ich persÃ¶nlich bevorzuge die <code>given</code>-<code>when</code>-<code>then</code>-Schreibweise, denn mit dieser kÃ¶nnen wir Unit-Tests vorher leicht in Prosa formulieren:</p>

<ul>
  <li><strong>Given</strong> a user with premium status</li>
  <li><strong>When</strong> this user makes a request</li>
  <li><strong>Then</strong> the user should receive 15 % discount</li>
</ul>

<p>Dies kann dann in einen konkreten Unit-Test wie folgt aussehen:</p>

<pre><code class="language-javascript">describe('getDiscountForUser', () =&gt; {
    let testSubject: DiscountController;
    
    beforeEach(() =&gt; {
        testSubject = new DiscountController();
    });
    
    it('should return 15 % discount when user has premium status', () =&gt; {
        // given a user with premium status
        const user = UserService.newWithPremiumStatus();
        
        // when this user makes a request
        const discount = testSubject.getDiscountForUser(user)
        
        // then the user should receive 15 % discount
        expect(discount.value).toEqual(15);
    });
    [...]
});
</code></pre>

<p>Keine Sorge, man braucht nicht mehr als <code>given</code>, <code>when</code> und <code>then</code> oder <code>arrange</code>, <code>act</code> und <code>assert</code> in den Unit-Test schreiben.
Dies habe ich hier nur gemacht, damit der Ãœbergang von den oben in Prosa geschrieben Texten zu der konkreten Testimplementierung besser nachvollzogen werden kann.</p>

<p>Durch das Aufteilen der Unit-Tests in diese drei Bereiche wird die Lesbarkeit gesteigert, was uns wiederum dabei unterstÃ¼tzt, AbhÃ¤ngigkeiten aufzudecken, besonders dann, wenn das Test-Setup mehr als nur eine Zeile Code ist.
Im Prinzip kÃ¶nnen wir unseren Unit-Test wie eine kleine Geschichte lesen.
Wir haben im <code>given</code>-Bereich eine Einleitung in der sich unsere Geschichte (bzw. unser Unit-Test) aufbaut.
Darauf steigt im <code>when</code>-Bereich der Spannungsbogen zum HÃ¶hepunkt, indem dort eine konkrete Handlung erfolgt (die TestausfÃ¼hrung).
Nun neigt sich die Geschichte im <code>then</code>-Bereich dem Ende zu und wir vergleichen die Ergebnisse der Handlung mit unseren Erwartungen, die wir vorher zu unserer Geschichte angenommen haben.
Zugegeben, es mag keine besonders spannende Geschichte sein, da wir schon im Vorfeld Annahmen treffen, die sich am Ende unserer Geschichte bewahrheiten sollen.
Allerdings ist dies ja schlieÃŸlich genau das, was wir in einem Unit-Test haben mÃ¶chten: Erwartungen, die sich bewahrheiten.
Letzten Endes sollte ein guter Unit-Test genauso leicht verstÃ¤ndlich sein wie eine einfache Geschichte.
Es sollte also keine plÃ¶tzlichen Site-Stories (SprÃ¼nge im Code) geben, die mich als Lesenden dazu zwingen, in der Geschichte hin und her zu springen, um das Gesamtbild zu durchblicken, sondern ich mÃ¶chte einen Unit-Test von oben nach unten einfach durchlesen und verstehen kÃ¶nnen.</p>

<h4 id="r---repeatable-">R - Repeatable ğŸ”„</h4>

<p>Unsere Unit-Tests sollen hÃ¤ufig und auf verschiedenen Umgebungen ausgefÃ¼hrt werden kÃ¶nnen, dabei liefern sie immer die gleichen Ergebnisse fÃ¼r die gleichen Eingaben.
Das bedeutet, ein Unit-Test liefert:</p>
<ul>
  <li>unabhÃ¤ngig von der Uhrzeit der AusfÃ¼hrung,</li>
  <li>unabhÃ¤ngig von den zuvor ausgefÃ¼hrten Unit-Tests und</li>
  <li>unabhÃ¤ngig von der Umgebung</li>
</ul>

<p>immer das gleiche nachvollziehbare Ergebnis zurÃ¼ck.</p>

<h4 id="s---self-validating-">S - Self Validating ğŸ“‹</h4>

<p>Unit-Tests sollen programmatisch das Ergebnis auswerten.
Wir mÃ¶chten nicht nach jeder TestausfÃ¼hrung selbst das Ergebnis auswerten mÃ¼ssen, indem wir bspw. in Log Files schauen.
Zumal gut getestete Projekte mit Leichtigkeit auf mehrere tausend Unit-Tests kommen.
Man stelle sich vor, man mÃ¼sse bei dieser Anzahl von Unit-Tests hÃ¤ndisch die Ergebnisse auswerten.
AuÃŸerdem sollte ein Unit-Test ein explizites und binÃ¤res Feedback geben, also <code>success</code> oder <code>fail</code> und nichts dazwischen.
Manchmal ist die Welt eben doch nur schwarz und weiÃŸ, bzw. rot und grÃ¼n.</p>

<h4 id="t---timely--thorough-">T - Timely / Thorough ğŸ•‘</h4>

<p>Robert C. Martin definiert das â€œTâ€ in F.I.R.S.T. mit â€œtimelyâ€.
Das bedeutet, Unit-Tests sollen schon vor dem produktiven Code geschrieben werden.
Dies macht das Schreiben von Unit-Tests leichter und der produktive Code wird zwangslÃ¤ufig testbar.
Es ist einfach schwerer, produktiven Code auf Anhieb testbar zu schreiben, als wenn man schon vorher einen Unit-Test hat, welcher einen dazu nÃ¶tigt, den produktiven Code testbar zu gestalten.</p>

<p>Mit der Zeit hat sich zum â€œTâ€ noch ein weiteres Prinzip eingeschlichen, und zwar â€œthoroughâ€.
â€œThoroughâ€ bedeutet Ã¼bersetzt â€œgrÃ¼ndlichâ€.
Wir schreiben also unsere Unit-Tests grÃ¼ndlich.
Dies erreichen wir, indem wir nicht nur TestfÃ¤lle fÃ¼r die ErfolgsfÃ¤lle, sondern auch fÃ¼r die FehlerfÃ¤lle, GrenzfÃ¤lle und <a href="https://de.wikipedia.org/wiki/%C3%84quivalenzklassentest">Ã„quivalenzklassen</a> schreiben.</p>

<p>Was dieses Prinzip letzten Endes bedeutet, lÃ¤sst sich an folgendem Beispiel zeigen:</p>

<p>So nehmen wir eine bekannte Kata (eine kleine abgeschlossene Ãœbung) â€œFizzBuzzâ€.
Diese Aufgabe sieht vor, dass:</p>

<ul>
  <li>fÃ¼r natÃ¼rliche Zahlen, die durch 3 teilbar sind, â€œfizzâ€ auf der Konsole ausgegeben werden soll,</li>
  <li>fÃ¼r natÃ¼rlichen Zahlen, die durch 5 teilbar sind, â€œbuzzâ€ auf der Konsole ausgeben werden soll,</li>
  <li>fÃ¼r natÃ¼rliche Zahlen, die sowohl durch 3 als auch durch 5 teilbar sind, â€œfizzbuzzâ€ auf der Konsole ausgegeben werden soll und</li>
  <li>fÃ¼r alle anderen Zahlen die jeweilige Zahl selbst auf der Konsole ausgeben werden soll.</li>
</ul>

<p>ZusÃ¤tzlich nehmen wir noch die Bedingung auf, dass nur Zahlen zwischen 1 und 30 berechnet werden sollen.
Bei Zahlen auÃŸerhalb unseres Intervalls soll ein Fehler geworfen werden.</p>

<p>Aus dieser Aufgabe ergeben sich nun diverse TestfÃ¤lle:</p>

<p><strong>Positiv-TestfÃ¤lle</strong></p>
<ul>
  <li><strong>Given</strong> is number 2. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œ2â€.</li>
  <li><strong>Given</strong> is number 3. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œfizzâ€.</li>
  <li><strong>Given</strong> is number 5. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œbuzzâ€.</li>
  <li><strong>Given</strong> is number 15. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œfizzbuzzâ€.</li>
</ul>

<p><strong>Fehlerfall-TestfÃ¤lle</strong></p>
<ul>
  <li><strong>Given</strong> is number -10. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> an error should be thrown.</li>
  <li><strong>Given</strong> is number 310. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> an error should be thrown.</li>
</ul>

<p><strong>Grenzwert-TestfÃ¤lle</strong></p>
<ul>
  <li><strong>Given</strong> is number 1. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œ1â€.</li>
  <li><strong>Given</strong> is number 30. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œfizzbuzzâ€.</li>
  <li><strong>Given</strong> is number 0. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> an error should be thrown.</li>
  <li><strong>Given</strong> is number 31. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> an error should be thrown.</li>
</ul>

<p><strong>TestfÃ¤lle fÃ¼r Ã„quivalenzklassenabdeckung</strong></p>
<ul>
  <li><strong>Given</strong> is number 6. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œfizzâ€.</li>
  <li><strong>Given</strong> is number 10. <strong>When</strong> fizzbuzz function executes, <strong>Then</strong> the answer should be â€œbuzzâ€.</li>
</ul>

<p>Man sieht in diesem Beispiel sehr gut, wie viele TestfÃ¤lle sich fÃ¼r solch eine einfache Aufgabe schreiben lassen, damit dieses Prinzip erfÃ¼llt ist.
Wir haben hier Erfolgsfall-, Fehlerfall- und GrenzwerttestfÃ¤lle geschrieben und zusÃ¤tzlich noch weitere, um alle Ã„quivalenzklassen abzudecken.
Zu beachten ist, dass die hier aufgefÃ¼hrten TestfÃ¤lle nicht in Stein gemeiÃŸelt sind.
Es gibt selbstverstÃ¤ndlich noch andere Zahlen, die man hier hÃ¤tte wÃ¤hlen kÃ¶nnte.
Auch die Anzahl an notwendigen TestfÃ¤llen ist variabel.
Denn Fakt ist, man kann nicht jedes Szenario testen und das mÃ¶chte man auch nicht.
Es wÃ¼rde einfach viel zu lange dauern und irgendwann ist der Mehrwert der Unit-Tests auch nicht mehr gegeben, da diese auch gewartet werden mÃ¼ssen.
Aus diesem Grund versuchen wir, so viele sinnvolle Tests zu schreiben wie mÃ¶glich, aber gleichzeitig auch so wenig wie nÃ¶tig.
Um dies zu erreichen, kann man sich folgende Fragen beim Schreiben von TestfÃ¤llen stellen:</p>

<ul>
  <li>Sind alle wichtigen PositivtestfÃ¤lle vorhanden?</li>
  <li>Sind alle wichtigen FehlerfalltestfÃ¤lle vorhanden?</li>
  <li>Habe ich alle Grenzwerte abgedeckt?</li>
  <li>Gibt es noch weitere Ã„quivalenzklassen, die ich noch testen sollte?</li>
</ul>

<h4 id="fazit-">Fazit ğŸ‰</h4>

<p>Nach Verinnerlichung und Verstehen dieser Prinzipien sollte das Schreiben von Unit-Tests etwas leichter von der Hand gehen.
Dennoch sollte man sich immer Bewusst sein, dass diese Prinzipien nicht dogmatisch angewendet werden sollten.
Man kann sich in einem Projekt auch auf andere Prinzipien festlegen oder diese Prinzipien abwandeln, wichtig ist hier das VerstÃ¤ndnis im Team.
Letzten Endes finden sich die Test-F.I.R.S.T.-Prinzipien in Projekten mit gut strukturierten Unit-Tests immer wieder, wenn auch eventuell in abgewandelter Form.</p>

</div>
</div>
</div>
</div>]]></field>
    </document>
</documents>
