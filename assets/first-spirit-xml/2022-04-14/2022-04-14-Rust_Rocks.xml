<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<documents>
    <document uid="7b3e6cf97014754c665fa84c0130e1dc">
        <field name="title"><![CDATA[Rust Rocks]]></field>
        <field name="subline"><![CDATA[]]></field>
        <field name="teaser"><![CDATA[<p>Hin und wieder treten neue Programmiersprachen auf den Plan, die meist schnell wieder in der Bedeutungslosigkeit verschwinden.
Nur selten wird eine neue Sprache gleichermaßen von einer großen Community getragen und von globalen IT-Firmen zur Umsetzung der eigenen Kernprojekte verwendet.<br />
Rust ist eine solche seltene Sprache.</p>

]]></field>
        <field name="language_multi_keyword"><![CDATA[de]]></field>
        <field name="content_type_multi_keyword"><![CDATA[blog]]></field>
        <field name="mime_type_multi_keyword"><![CDATA[text/html]]></field>
        <field name="category_multi_keyword"><![CDATA[Softwareentwicklung]]></field>
        <field name="tag_multi_keyword"><![CDATA[Rust]]></field>
        <field name="tag_multi_keyword"><![CDATA[Nachhaltigkeit]]></field>
        <field name="tag_multi_keyword"><![CDATA[Energieeffizienz]]></field>
        <field name="tag_multi_keyword"><![CDATA[Performance]]></field>
        <field name="date_date"><![CDATA[2022-04-14T09:00:00+02:00]]></field>
        <field name="date_l"><![CDATA[1649919600000]]></field>
        <field name="change_date"><![CDATA[1649919600000]]></field>

        <!--Author Information-->
        <field name="author_id"><![CDATA[christianlunau]]></field>

        <!--Postcontent-->
        <field name="headlines"><![CDATA[Rust Rocks]]></field>
        <field name="display_content"><![CDATA[<div class="i2-intro p-t-1">
            <p>Hin und wieder treten neue Programmiersprachen auf den Plan, die meist schnell wieder in der Bedeutungslosigkeit verschwinden.
Nur selten wird eine neue Sprache gleichermaßen von einer großen Community getragen und von globalen IT-Firmen zur Umsetzung der eigenen Kernprojekte verwendet.<br />
Rust ist eine solche seltene Sprache.</p>

</div>]]></field>
        <field name="content"><![CDATA[<div class="adesso-text-formate">
<div class="row p-t-2">
<div class="adesso-container">
<div class="col-xl-8 adesso-center p-b-1 p-l-0 p-r-0">
    <p>Hin und wieder treten neue Programmiersprachen auf den Plan, die meist schnell wieder in der Bedeutungslosigkeit verschwinden.
Nur selten wird eine neue Sprache gleichermaßen von einer großen Community getragen und von globalen IT-Firmen zur Umsetzung der eigenen Kernprojekte verwendet.<br />
Rust ist eine solche seltene Sprache.</p>

<h4 id="rust-rocks">Rust Rocks!</h4>

<p><strong><em>Nachhaltigkeit, Performance und Sicherheit.</em></strong></p>

<h5 id="was-ist-rust">Was ist Rust?</h5>

<p>Rust ist eine Multiplattform- und <a href="https://de.wikipedia.org/wiki/Programmierparadigma">Multiparadigmen-</a>Programmiersprache, die als Open Source veröffentlicht wurde und von einer großen Community aktiv weiterentwickelt wird. Die Sprache ist darauf ausgelegt, möglichst viele Aspekte für Performance und Sicherheit so anzubieten, dass diese schon zur Compile-Zeit erzielt werden und während der Laufzeit der erzeugten Applikationen nicht mehr erledigt werden müssen. Das erspart z.B. aufwendiges Speichermanagement und Aufräumen mittels Garbage-Collector-Mechanismen, was sowohl der Laufzeitperformance wie auch der Vorhersagbarkeit von Laufzeiten zugute kommt.</p>

<p>Aufgrund der Struktur von Rust sind die Kosten der Sprachabstraktionen so gering wie nur möglich, wodurch eine mit C/C++ vergleichbare <a href="https://prev.rust-lang.org/de-DE/faq.html#how-fast-is-rust">Performance</a> möglich wird, ohne dabei die benötigte Speichersicherheit zu vernachlässigen. So wird z.B. zur Compile-Zeit durch einen Borrow-Checking genannten Mechanismus sichergestellt, dass jederzeit(!) klar ist, welcher Variableninhalt aktuell gültig (und in-scope) ist. Stichwort Highlander-Prinzip: Es kann nur einen (<a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html#the-rules">Owner eines Speicherbereichs</a>) geben. Alle anderen dürfen gucken (Speicherinhalt lesen), aber nicht anfassen (Speicherinhalt verändern). Verlässt der Besitzer den Raum (geht ‘out of Scope’), geht der Besitz in die Tonne (gehaltener Speicher wird automatisch freigegeben).</p>

<p>Dass alles korrekt koordiniert wird, wird durch den Borrow-Checker zur Compile-Zeit sichergestellt. Ein im Hintergrund laufender Garbage-Collector zum Einsammeln der freien Speicherbereiche ist nicht erforderlich.</p>

<p>Kein dauernd laufender Aufräumprozess im Hintergrund bedeutet:<br />
-&gt; kein zusätzlicher Laufzeitaufwand<br />
-&gt; somit geringere Anzahl ausgeführter CPU-Befehle<br />
-&gt; höhere Performance und geringerer Energiebedarf.</p>

<p>Zudem wird Rust-Sourcecode nativ kompiliert, was die Grundlage für die hohe Performance ist: Zur Laufzeit wird nicht mehr interpretiert oder als Bytecode durch eine Virtuelle Maschine verarbeitet. Rust-Programme sind wie Eisenoxid - nah am “Bare Metal” der Maschine, da ist nichts mehr dazwischen.</p>

<h5 id="wer-steckt-dahinter">Wer steckt dahinter?</h5>

<p><img src="/assets/images/posts/Rust_Rocks/RustFoundation_Mitglieder.png" alt="Rust_Mitglieder_und_Sponsor" title="Rust Mitglieder und Sponsor" /></p>

<p>Ursprünglich wurde Rust von Mozilla entwickelt, bevor die Aufsicht über die Weiterentwicklung dann an die Ende 2020 neu gegründete <a href="https://foundation.rust-lang.org/">Rust Foundation</a> übergeben wurde.<br />
Gründungsmitlieder der Foundation sind <a href="https://www.microsoft.com/de-de/">Microsoft</a>, <a href="https://www.huawei.com/en/?ic_medium=direct&amp;ic_source=surlent">Huawei</a>, <a href="https://www.google.com/">Google</a>, <a href="https://aws.amazon.com/de/">Amazon/AWS</a> und <a href="https://www.mozilla.org/de/">Mozilla</a>.
Diese stellen auch das Board of Directors.
Dazu kommt noch <a href="https://opensource.fb.com/">Meta (Facebook)</a> als Platin-Sponsor und weitere bekannte Namen wie z.B. <a href="https://www.arm.com/">arm</a>, <a href="https://www.dropbox.com/">Dropbox</a>, <a href="https://threema.ch/de">Threema</a> und <a href="https://www.toyotaconnected.com/">Toyota-Connected</a>.</p>

<p>Aber fast am Wichtigsten ist die hinter Rust stehende
<strong><em>extrem positive und hilfsbereite Community!</em></strong><br />
Einen guten Einstieg bietet zum Beispiel die Seite <a href="https://users.rust-lang.org/">users.rust-lang.org</a>.</p>

<h6 id="und-was-machen-die-mit-rust">…und was machen die mit Rust?</h6>

<ul>
  <li><strong>Mozilla</strong>: Mozilla verwendet Rust in vielen seiner Hauptapplikationen, u.A. <a href="https://servo.org/">Servo</a> und <a href="https://medium.com/mozilla-tech/a-quantum-leap-for-the-web-a3b7174b3c12">Schlüsselkomponenten von Firefox</a></li>
  <li><strong>Dropbox</strong>: Mehrere <a href="https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine">Komponenten des Dropbox Kern-Dateispeichersystems</a> wurden in Rust neu geschrieben mit dem Ziel, eine höhere Effizienz im Datacenter zu erreichen. Es wird aktuell für jeglichen Dropbox-Speicher verwendet und bedient über 500 Millionen anwendende Personen.</li>
  <li><strong>Amazon/AWS</strong>: Amazon/AWS hat kürzlich wichtige Teile der Video-App für Prime Video <a href="https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types">von JavaScript auf Rust + Webassembly umgestellt</a>. Dabei seien in ersten Tests  Geschwindigkeitssteigerungen um das 10- bis 25-fache erreicht worden. Die Bildwiederholrate nähert sich dadurch nun 60 FPS auf jedem der unterstützten Geräte.<br />
AWS hat Rust schon länger für performancekritische Dinge in Lambda, EC2 und S3 verwendet. Die <a href="https://firecracker-microvm.github.io/">Firecracker VMM</a> ist komplett in Rust geschrieben.</li>
  <li><strong>Google</strong>: Google hat sein experimentelles Betriebssystem <a href="https://fuchsia.dev/fuchsia-src/development/languages/rust">Fuchsia</a> zum <a href="https://www.reddit.com/r/rust/comments/k9r3s4/fuchsia_lines_of_code_over_last_two_years_c_c_rust/">Teil in Rust</a> geschrieben, plant <a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html">Rust als Systemsprache für Android</a> einzuführen und untersucht Möglichkeiten, die Speichersicherheit in <a href="https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html">Chrome durch Verwendung von Rust zu verbessern</a>.</li>
  <li><strong>Microsoft</strong>: Microsoft hat mit <a href="https://crates.io/crates/windows">Rust for Windows</a> einen Rust crate veröffentlicht, der es ermöglichen soll die komplette Windows-Api aus Rust heraus zu nutzen und bietet mittlerweile selbst eine <a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Schulung zu Rust</a> an. Siehe auch <a href="https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/">Microsoft: Why Rust for safe systems programming</a>.</li>
  <li><strong>Meta/Facebook</strong>: Meta/Facebook hat seinen Source Control Backend von Python nach Rust portiert, hier ein <a href="https://youtu.be/kylqq8pEgRs">Video zu dem Thema</a> von einer der Rust-Konferenzen.</li>
</ul>

<p>Und sonst so?</p>

<p>Eine ganze Reihe von Firmen und Organisationen setzen mittlerweile Rust in ihren Projekten ein, hier eine Liste von <a href="https://www.rust-lang.org/production/users">production users</a>. Eine weitere Aufstellung von Projekten ist von Sylvain Kerkour in <a href="https://kerkour.com/rust-in-production-2021/">Rust in Production 2021</a> veröffentlicht worden.</p>

<p>An dieser Stelle noch zwei Beispiele:</p>

<p><em>Discord:</em> Hier werden Rust und Elixir verwendet, um eine Skalierung auf 11 Million gleichzeitige Nutzer mittels Elixir NIFs (Native Implemented Functions) zu realisieren. Dabei <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f">ermöglicht Rust eine Beschleunigung der bestehenden Elixir codebase, wobei gleichzeitig die Speichersicherheit gewährleistet wird</a>. Zusätzlich wurde der Read States Service in Rust neu geschrieben, der ursprünglich in Go implementiert worden ist. Während die Go-Version des Services zwar meist schnell genug war, kam es gelegentlich zu großen Latenzspitzen, welche sich auf Go’s Speichermodell und den dabei verwendeten Garbage-Collector zurückführen ließen. Um dies zu beheben hat Discord zu Rust gewechselt, das über ein einzigartiges memory allocation system verfügt, welches garbage-collection unnötig macht.</p>

<p><em>Rust auf dem Weg in den Linux-Kernel:</em> Es sind bereits einige (zunächst kleine) <a href="https://www.golem.de/news/programmierung-rust-landet-erstmals-in-wichtigem-linux-kernel-zweig-2103-155134.html">Teile im Linux-Kernel in Rust implementiert</a> worden, <a href="https://www.golem.de/news/programmiersprache-linus-torvalds-kann-sich-rust-im-linux-kernel-vorstellen-2007-149627.html">Linus Torvalds steht dem vorsichtig-positiv</a> gegenüber.<br />
Das <a href="https://github.com/Rust-for-Linux/linux">Rust-4-Linux</a>-Team hat mittlerweile einen Großteil der Linux-C-API in Rust verfügbar gemacht, sodass dieser für in Rust geschriebene Kernel-Mode-Programme/Module verfügbar ist.</p>

<h5 id="worauf-läufts">Worauf läuft’s?</h5>

<p>Die Rust-Build-Umgebung selbst und mit Rust erzeugte Programme laufen auf <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">allen relevanten Betriebssystem-CPU-Kombinationen</a>.</p>

<p>Von den Rust-Maintaineren gibt es eine in drei Tiers abgestufte <strong>Zusicherung der Lauffähigkeit</strong>. Für die folgenden Plattformen ist die Lauffähigkeit garantiert (dies wird als ‘Tier 1’ bezeichnet):</p>

<ul>
  <li>64-bit MSVC (MS-Windows ab Version 7)</li>
  <li>64-bit Linux (kernel 2.6.32+, glibc 2.11+)</li>
  <li>64-bit macOS (10.7+, Lion+)</li>
  <li>64-bit MinGW (Windows 7+)</li>
  <li>ARM64  Linux (kernel 4.2, glibc 2.17+)</li>
  <li>32-bit MSVC (Windows 7+)</li>
  <li>32-bit MinGW (Windows 7+)</li>
  <li>32-bit Linux (kernel 2.6.32+, glibc 2.11+)</li>
</ul>

<p>Zu den weiteren unterstützten Plattformen zählen Kombinationen aus einer Vielzahl von CPU-Varianten wie x86/i686/AMD64, ARM, MIPS, PowerPC, RISC-V, SPARC mit Betriebssysteme wie Android, iOS, Fuchsia, Solaris, Illumos, BSD und diversen Varianten von Linux sowie ein paar Exoten.</p>

<p>Tom Heimbrodt kommt 2019 in seiner Bachelorarbeit <a href="https://comsys.ovgu.de/comsys_media/thesis/finished/BSc/2019+_+Tom+Heimbrodt+_+Evaluierung+der+Sprache+Rust+zur+Programmierung+von+Mikrocontrollern-p-392.pdf">“Evaluierung der Sprache Rust zur Programmierung von Mikrocontrollern” (PDF)</a> für die Universität Magdeburg zu dem Schluss, dass die Hardwareunterstützung im Mikrocontroller-Bereich schon gut, aber ausbaufähig ist. Er untersucht hier neben der generellen Lauffähigkeit vordringlich Performance und Speicherverbrauch, die oft in der Nähe der zum Vergleich herangezogenen Implementierungen als C-Applikationen liegen.</p>

<p>Durch die <a href="https://rustwasm.github.io/docs/book/">Unterstützung von WebAssembly/WASM</a> rückt Rust in die Nähe von JavaScript-Entwicklungen und ermöglicht die Realisierung von <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm">höher Performanten Applikationen auch für Web-Umgebungen</a>. Elisabeth Schulz hat das in ihrem im Juni 2021 auf Informatik Aktuell veröffentlichten Artikel <a href="https://www.informatik-aktuell.de/betrieb/virtualisierung/serverless-und-doch-metal-aws-lambda-mit-rust.html">“Serverless und doch Metal: AWS Lambda mit Rust”</a> näher beleuchtet.</p>

<p>Mit Hilfe von CI-Pipelines in <a href="https://github.com/">GitHub</a>-Actions, <a href="https://www.travis-ci.com/">TravisCI</a>, <a href="https://www.appveyor.com/">AppVeyor</a> oder anderen lassen sich Builds, Tests und Deployment auch für unterschiedliche Plattformen parallel durchführen.</p>

<h5 id="was-macht-rust-besonders">Was macht Rust besonders?</h5>

<ul>
  <li><a href="https://winfuture.de/news,124128.html">Memory safety</a>: Zur Compile-Zeit durchgesetzt, zur Laufzeit ohne Performanceverluste vorhanden</li>
  <li>Performance: Nahe beim erreichbaren Maximum</li>
  <li>Energieeffizienz: Durch die sparsame Nutzung der Computerresourcen (damit ist geringer CPU-Anspruch und moderater RAM-Speicherverbrauch gemeint) wird für die Ausführung von Rustprogrammen verhältnismäßig wenig Energie benötigt.</li>
  <li>Multiplattform: von Anfang an nicht nur portabel, sondern portiert</li>
  <li>Fehlermeldungen zur Compile-Zeit, die nicht nur Sinn ergeben, sondern hilfreich bis lehrreich sind</li>
  <li><a href="https://doc.rust-lang.org/cargo/guide/index.html">Cargo</a>: Integriertes Standard-Build-Tool und <a href="https://crates.io/">Repository</a>-Integration</li>
  <li>Dependencies (zu Versionen von crates (Libraries)) werden ebenfalls von cargo gehandhabt.</li>
  <li>Durch standardisierte und einfach steuerbare Dependencies kann auf entdeckte Security Vulnerabilities in Open Source Libraries schnell und leicht reagiert werden.</li>
  <li><a href="https://dev.to/cloudx/rust-and-the-hidden-cargo-clippy-2a2e">cargo clippy</a>: bietet ausgefeiltes static linting</li>
  <li><a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html">cargo doc</a>: Automatisierte Dokumentationserstellung mittels ‘Inline-comment to html-doc’ im Standard mitgeliefert</li>
</ul>

<p><strong>Die Kombination von geringem Energieverbrauch, hoher Performance und gleichzeitig hoher Speichersicherheit macht Rust einzigartig.</strong></p>

<p>Insgesamt bietet Rust schon mit dem mitgelieferten Build-Tool cargo eine umfassende und moderne Programmierumgebung, deren Möglichkeiten bei anderen Programmiersprachen erst durch Ergänzung weiterer, externer Tools annähernd erreicht werden könnte.<br />
Mit dem Plugin <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">RustAnalyzer</a> existiert zudem eine hervorragende Einbindung in die Visual Studio Code IDE.</p>

<h6 id="energieeffizienz">Energieeffizienz</h6>

<p>Heute eingesetzte Programme laufen oft und viel auf Geräten, bei denen der Energiebedarf direkt mit der Nutzbarkeitsdauer des Gerätes gekoppelt ist. Smartphones zum Beispiel bedanken sich mit längerer Akkulaufzeit für höherperformante Apps. Erst recht gilt das, je kleiner die Geräte werden, z.B. im IOT-Bereich.</p>

<p>Aber auch am anderen Ende der Skala ist Energieverbrauch von Software durchaus relevant: In großen Rechenzentren ist die erzeugte und abzuführende Temperatur direkt gekoppelt mit der Last, die auf den CPUs der Maschinen liegt. Mit effizienterer Software kann nun entweder mit der selben Last mehr getan werden (mehr Kunden bedient werden) oder die Dimensionierung der Maschinen kann für dieselbe Leistung kleiner ausfallen und somit z.B. kostbaren Strom sparen.</p>

<p>In Zeiten, in denen wir aktiv planen, die schon sichtbaren Auswirkungen des Klimawandels zu verringern, ist Energieeffizienz <strong>sehr relevant</strong>.</p>

<p>Dass durch höhere Performance der gelieferten Applikationen die User glücklicher werden können ist dabei ein weiterer schöner Effekt.</p>

<p>Durchaus vorstellbar ist zudem, dass schon bald auf Nachhaltigkeit bedachte europäische Regierungen die Energieeffizienz von industriellen Erzeugnissen (also auch Software) einfordern werden. Vielleicht in Form einer genaueren Ausarbeitung der <a href="https://www.europarl.europa.eu/factsheets/de/sheet/69/energieeffizienz">Energieeffizienzrichtlinie des Europaparlaments</a> im Rahmen der <a href="https://www.greenit-solution.de/europaeische-rechenzentren-sollen-bis-2030-klimaneutral-sein">Green-IT</a> Initiative.</p>

<p>Die Effizienz der Erstellung von Software, also die Zeit, die wir benötigen um sie korrekt lauffähig, sicher und schön zu machen, ist im Vergleich zur später anfallenden Betriebslaufzeit verschwindend gering. Das gilt insbesondere dann, wenn man die Zeit mit der Anzahl der Installationen/Geräte multipliziert.<br />
Es muss also völlig egal sein, ob zur Software-Erstellung jetzt Zeit J oder eine geringfügig längere Zeit R benötigt wird, wenn durch verbesserte Energieeffizienz und Performance dann während der Betriebszeit dauerhaft weniger Energie verbraucht wird. Da fertige Rust-Applikationen zudem noch mit hoher Wahrscheinlichkeit durch weniger Laufzeitprobleme (weil z.B. Speicherfehler vermieden werden) und angenehmere User-Experience (durch kürzere Response-Zeiten) die Menschen erfreuen, ist erst recht klar, dass wir alle davon profitieren.</p>

<p>Betrachtet man als Entwicklungszeit nicht die Zeit bis zur Auslieferung der ersten Version eines Produktes, sondern bis es nachprüfbar stabil und verlässlich auch ‘im Feld’ läuft, dann kann erwartet werden, dass diese Fertigstellungszeit in Rust eher kürzer ist als bei Projekten in solchen Programmiersprachen, die ihren Reifegrad erst zur Anwendungszeit entfalten.</p>

<h6 id="studie-zur-energieeffizienz-von-programmiersprachen">Studie zur Energieeffizienz von Programmiersprachen</h6>

<p>Vor einiger Zeit hat eine Forschergruppe in Portugal (Rui Pereira
HASLab/INESC TEC, Universidade do Minho, Portugal et al.: <a href="https://www.sciencedirect.com/science/article/abs/pii/S0167642321000022?via%3Dihub">Energy Efficiency across Programming Languages</a>) näher untersucht, wie es mit Ausführungsgeschwindigkeit, Speicherverbrauch, Startzeiten, Kompilierdauer und weiteren Details bei verschiedenen Programmiersprachen aussieht und im Mai 2021 dazu einen vielbeachteten Artikel veröffentlicht. Eine ältere Vorversion dieser Arbeit kann man sich <a href="https://greenlab.di.uminho.pt/wp-content/uploads/2017/09/paperSLE.pdf">hier</a>) ansehen.</p>

<p>Dabei wurden für alle beteiligten Sprachen jeweils möglichst effiziente Implementierungen für dieselben Algorithmen gewählt und diese auf derselben Hardware und in derselben Betriebssystemumgebung ausgeführt.</p>

<p>Ende Mai 2021 hat <a href="https://scienceblogs.de/rupture-de-catenaire/2021/05/03/die-energie-effizienz-von-programmiersprachen/">Christian Meesters diese Ergebnisse noch mal aufbereitet</a> und die Ergebnisse im folgenden Diagramm übersichtlich dargestellt:</p>

<p><img src="/assets/images/posts/Rust_Rocks/Energieeffizienz_all_languages.png" alt="energy_efficiency_langs" title="Energy-Efficiency langs" /><br />
Das Diagramm ist freundlicherweise unter der sehr freigiebigen <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.de">CC-BY SA 4.0-Lizenz</a> veröffentlicht.</p>

<p>Zu sehen ist hier jeweils der Energieverbrauch des Test-Sets an Implementierungen, relativ normiert zu der energiesparendsten Sprache, welche C ist und die den Wert ‘1’ erhalten hat. Die anderen Sprachen benötigen für dieselben Aufgaben dementsprechend die Y-fache Energie.</p>

<p>Schaut man sich die Ergebnisse im Detail an, dann ergibt sich aus der Originalstudie, dass für diese Berechnungsaufgaben Rust etwa 3,5% mehr Energie benötigt als C und beide auch fast gleich schnell sind. Java-Applikationen benötigen ungefähr doppelt so viel Energie und Zeit wie Rust-Applikationen. Insbesondere benötigen Lösungen in VM-basierten Sprachen und erst recht Skript-Sprachen generell ein Vielfaches der Energie und Zeit von compilerbasierten Sprachen.</p>

<p>Je nach tatsächlich getestetem Algorithmus weichen in der Studie die Werte ein wenig ab, bleiben in ihrer Relation zueinander aber im Wesentlichen gleich angeordnet.</p>

<p>Betrachtet man statt der zum Energieverbrauch analogen Performance die bei der Ausführung benötigten RAM-Mengen, so ist das Ergebnis ähnlich:<br />
Rust benötigt hier zwar 54% mehr RAM (Faktor 1,54) als die speichersparsamste Programmiersprache, welche in diesem Vergleich Pascal ist. Der Speicherbedarf der Pascal-Programme liegt sehr knapp unter denen in Go und C. Im Vergleich zum Rust-Speicherbedarf benötigt aber zum Beispiel JavaScript das 4,56-fache, Java das 6,01-fache und das Schlusslicht im Speicherverbrauch, Jruby das 19,84-fache an RAM.</p>

<p>Kritisch betrachtet ist natürlich nicht jede Sprache für dieselben Zwecke gleich sinnvoll einzusetzen. So eignen sich Skriptsprachen gut für ‘mal eben’ zu implementierende Datenstromverarbeitungen auf Backend-Rechnern, während sich kompilierte Applikationen eher für Anwendungsfälle eignen, in denen es auf maximalen Datendurchsatz oder verlässlich-schnelle Reaktionszeiten an kommt.</p>

<p>Unangenehmer Weise gibt es hier eine <strong>Korrelation zwischen der beobachteten Energieeffizienz einer Sprache und ihrer Erlernbarkeit</strong>:<br />
Gerade die effizienten Sprachen sind eher schwerer zu erlernen. Während man mit Perl mal schnell was Lauffähiges hingekritzelt bekommt und in Java recht zügig Programme erzeugt werden können, die so aussehen als würden sie nicht abstürzen, ist das bei Rust anders: Beim Kompiliervorgang steht hier zum Beispiel der Speicher-Wächter (Borrow-Checker) vor der Tür und spricht ein deutliches “You shall not pass!”, bis auch wirklich alle Referenzen und Speichergültigkeiten (scopes, lifetimes) korrekt behandelt sind.<br />
Danach hat man dann allerdings auch eine gewisse Sicherheit, dass das erzeugte Kompilat korrekt mit dem Speicher umgeht.</p>

<h6 id="security">Security</h6>

<p><strong>Die Log4J-Lücke, jemand betroffen?</strong></p>

<p>Gegen Features, die explizit in eine Applikation oder Library hineinprogrammiert werden, kann auch eine noch so gute Absicherung in der verwendeten Programmiersprache nichts machen.<br />
Gäbe es im Rust-Ökosystem ein vergleichbar programmiertes Library Feature, dann wäre auch hier ‘die Kacke am Dampfen’ gewesen.<br />
Schaut man sich an, wie die Rust-Community, in diesem Fall speziell die Language- und Crate-Maintainer, mit anderen Sicherheitslücken umgegangen sind, dann findet man folgendes:</p>

<p>Ende 2021 gab es einen <a href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">Bug im Unicode-Handling</a> des Rust-Compilers, der potenziell dazu hätte genutzt werden können, im Sourcecode verschleiert ineffektive Zugangsprüfungen einzuschleusen. Dabei sieht der Sourcecode für einen menschlichen Leser zunächst ok aus, der Compiler ersetzt dann aber die Prüfung einer Passwortvariablen mit einem konstanten Wert.</p>

<p>Das ist nicht ganz so eine Katastrophe wie der Log4Shell-Bug, aber definitiv unschön.</p>

<p>25.07.2021: Die Vulnerability wurde an das zuständige Rust-Team gemeldet, welches mit der Arbeit an einer Lösung begann.<br />
14.09.2021: Dem Team wird der Termin 01.11.2021 für die Presseveröffentlichung des Problems mitgeteilt.<br />
Bis 17.10.2021 sind dann ALLE jemals auf dem zentralen Repository für Rust Libraries (crates.io) veröffentlichen Sourcen auf diese Angreifbarkeit hin analysiert worden. Insgesamt wurden dabei 5 Sourcen gefunden, die eine dem Angriffszenario ähnelnde Unicode-Prüfung enthielten, keine davon war tatsächlich bösartig.<br />
01.11.2021: Das Presse-Embargo wird aufgehoben, die Angreifbarkeit veröffentlicht und das gefixte Rust 1.56.1 herausgegeben. Zum Beispiel <a href="https://www.heise.de/news/Angreifer-koennten-Source-Code-trojanisieren-der-trotzdem-legitim-aussieht-6237686.html">schreibt heise hier darüber</a>.</p>

<p>Nun ist die Angreifbarkeit hierbei anders geartet als bei Log4J: Während es bei der Java Logging Library reicht, einen bösartigen Text durch beliebige, fremde Software loggen zu lassen, muss bei dem Unicode-Check schon Sourcecode in ein Endprodukt eingeschleust werden. Theoretisch ist das über Open Source Libraries möglich, die allerdings im Falle von Rust fast ausschließlich über das crates.io-Repository angeboten werden. Wie das Rust-Team gezeigt hat, kann hier durchaus nach Sicherheitslücken gefahndet werden und diese können ggf. auch rechtzeitig behoben werden.</p>

<p>Das ist aber nur die halbe Miete:<br />
Wie bekommen Anwendende denn jetzt die bereinigte Version auf ihre Rechner? Hier wird’s etwas vertrackt. Anders als bei vielen gebräuchlichen Programmiersprachen werden Applikationen in Rust im Normalfall statisch gelinkt. Das bedeutet, dass man zwar einerseits der DLL-/Shared-Library-Hölle entkommt (und einige weitere Vorteile hat), andererseits aber auch, dass eine anfällige Library nicht, wie bei Log4J, mal eben durch Betreibende/Anwendende ausgetauscht werden kann. Denn es steckt ja alles in der fertig gelinkten Applikation. Hier muss also zunächst der Anbietende/Entwickelnde tätig werden und eine neue Version des Executables erstellen. Vorzugsweise, bevor die Vulnerability der verwendeten Library veröffentlicht wird…</p>

<p>Einerseits können Anwendende/Betreibende bei Rust-Applikationen keine Sicherheitslücke durch Austauschen einer externen Bibliothek fixen, andererseits muss man das bei Rust auch nicht: Die Pflege der Anwendungsbinaries selbst obliegt den Anbietenden, also zum Beispiel uns - machen wir dann doch gerne.</p>

<h5 id="anekdote-der-your-code-is-inefficient-error">Anekdote: Der Your-Code-Is-Inefficient-Error</h5>

<p>Der folgende Screenshot zeigt eine Konsolenausgabe, wie sie der Rust-Compiler im Fehlerfall typischerweise zeigt. Man sieht einen Code-Ausschnitt mit Zeilennummern und exakten Angaben, wo welcher Fehler auftritt, oft auch gleich angereichert mit Hinweisen zu Fehlerbehebung und Verbesserung des Codesegments:
<img src="/assets/images/posts/Rust_Rocks/bubblesort_as_a_Bug.jpg" alt="bubblesort_as_a_Bug" title="Bubblesort as a Bug" /></p>

<p>Bitte genau hinschauen: der Compiler bemängelt hier, dass der Entwickler offensichtlich etwas sortieren will, dafür aber den bekanntermaßen ineffizienten Algorithmus ‘Bubblesort’ gecodet hat. Dies lehnt der Compiler mit einer Fehlermeldung ab…</p>

<p>OK, das ist ein in der Rust-Community entstandener Hoax, so weit geht der Compiler dann doch nicht; Dass dieser Scherz in der Community so ausgebrütet wurde und der Screenshot nach seiner Veröffentlichung viral ging, zeigt aber auch, welchen Stellenwert hilfreiche Fehlermeldungen in der Rust-Community haben. Viele Fehlermeldungen sehen tatsächlich so ähnlich aus, haben eine treffende Genauigkeit und sind mit vergleichbar hilfreichen Informationen versehen. Zu einem gewissen Grad kann man dadurch mittels Try-and-Error das Programmieren in Rust erlernen. Das geht mit Rust besser als in wohl jeder anderen Sprache.</p>

<h5 id="warum-ist-rust-für-adesso-interessant">Warum ist Rust für adesso interessant?</h5>

<ul>
  <li>Nachhaltigkeit und Energieeffizienz</li>
  <li>Hohe Performance spart auch die Zeit jedes und jeder Anwendenden</li>
  <li>Stabilität von Applikationen wird frühzeitiger erreicht</li>
  <li>Technische Qualität der Applikation steigt</li>
  <li>Die Gesamtzeit, bis ein stabiles Produkt entstanden ist, kann verringert werden.</li>
</ul>

<h5 id="fazit">Fazit</h5>

<p>Die Zeit, welche die Vielzahl von Anwendenden damit verbringen, auf Ergebnisse von Softwareberechnungen zu warten oder sich durch zähe Anwendungen zu schleppen, ist nicht zuletzt auch Lebenszeit, die jeder sicherlich sinnvoller als gerade mit Warten verbringen möchte.</p>

<p>Insbesondere in Zeiten, in denen die zurechnungsfähige Welt das Klima retten will, ist Energieeffizienz ein wesentliches Qualitätsmerkmal von Softwareprodukten.</p>

<p>Da Rusts Speichersicherheitsmethodik gerade bei langlaufenden Anwendungen zu erhöhter Stabilität und auch verlässlicheren Antwortzeitverhalten führt, kann hier ein verbessertes Verhalten der Software im Betrieb erwartet werden.</p>

<p>Zusammen mit einem guten Tool-Ökosystem und dem freundlich-hilfreichen Compilerverhalten wird daraus ein Gesamtpaket, dass insbesondere für die Implementierung ernsthafter Anwendungen unübertroffen ist.</p>

<p><strong>Rust Rocks!</strong></p>

<h5 id="quellen">Quellen</h5>

<p>Die meisten Quellen sind im Text jeweils direkt verlinkt.</p>

<p>Hier noch ein paar gesonderte Quellangaben:</p>

<p>Christian Meesters (ScienceBlogs.de, 03.05.2021): <a href="https://scienceblogs.de/rupture-de-catenaire/2021/05/03/die-energie-effizienz-von-programmiersprachen/">Die Energie-Effizienz von Programmiersprachen</a></p>

<p>Elisabeth Schulz (auf Informatik Aktuell, 08.06.2021): <a href="https://www.informatik-aktuell.de/betrieb/virtualisierung/serverless-und-doch-metal-aws-lambda-mit-rust.html">Serverless und doch Metal: AWS Lambda mit Rust</a></p>

<p>Heise.de (2020): <a href="https://www.heise.de/hintergrund/Entwicklung-Warum-Rust-die-Antwort-auf-miese-Software-und-Programmierfehler-ist-4879795.html">Warum Rust die Antwort auf miese Software und Programmierfehler ist</a></p>

<p>Golem.de (2016): <a href="https://www.golem.de/news/rust-ist-die-neue-programmiersprache-besser-1606-121227.html">Ist die neue Programmiersprache besser?</a></p>


</div>
</div>
</div>
</div>]]></field>
    </document>
</documents>
